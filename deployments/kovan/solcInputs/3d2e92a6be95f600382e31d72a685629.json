{
  "language": "Solidity",
  "sources": {
    "contracts/BActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\nlibrary RightsManager {\n    struct Rights {\n        bool canPauseSwapping;\n        bool canChangeSwapFee;\n        bool canChangeWeights;\n        bool canAddRemoveTokens;\n        bool canWhitelistLPs;\n        bool canChangeCap;\n    }\n}\n\nabstract contract ERC20 {\n    function approve(address spender, uint amount) external virtual returns (bool);\n    function transfer(address dst, uint amt) external virtual returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external virtual returns (bool);\n    function balanceOf(address whom) external view virtual returns (uint);\n    function allowance(address, address) external view virtual returns (uint);\n}\n\nabstract contract BuniOwnable {\n    function setController(address controller) external virtual;\n}\n\nabstract contract AbstractPool is ERC20, BuniOwnable {\n    function setSwapFee(uint swapFee) external virtual;\n    function setPublicSwap(bool public_) external virtual;\n\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external virtual;\n    function joinswapExternAmountIn(\n        address tokenIn, uint tokenAmountIn, uint minPoolAmountOut\n    ) external virtual returns (uint poolAmountOut);\n}\n\nabstract contract BPool is AbstractPool {\n    function finalize() external virtual;\n    function bind(address token, uint balance, uint denorm) external virtual;\n    function rebind(address token, uint balance, uint denorm) external virtual;\n    function unbind(address token) external virtual;\n    function isBound(address t) external view virtual returns (bool);\n    function getCurrentTokens() external view virtual returns (address[] memory);\n    function getFinalTokens() external view virtual returns(address[] memory);\n    function getBalance(address token) external view virtual returns (uint);\n}\n\nabstract contract BFactory {\n    function newBPool() external virtual returns (BPool);\n}\n\nabstract contract ConfigurableRightsPool is AbstractPool {\n    struct PoolParams {\n        string poolTokenSymbol;\n        string poolTokenName;\n        address[] constituentTokens;\n        uint[] tokenBalances;\n        uint[] tokenWeights;\n        uint swapFee;\n    }\n\n    struct CrpParams {\n        uint initialSupply;\n        uint minimumWeightChangeBlockPeriod;\n        uint addTokenTimeLockInBlocks;\n    }\n\n    function createPool(\n        uint initialSupply, uint minimumWeightChangeBlockPeriod, uint addTokenTimeLockInBlocks\n    ) external virtual;\n    function createPool(uint initialSupply) external virtual;\n    function setCap(uint newCap) external virtual;\n    function updateWeight(address token, uint newWeight) external virtual;\n    function updateWeightsGradually(\n        uint[] calldata newWeights, uint startBlock, uint endBlock\n    ) external virtual;\n    function commitAddToken(address token, uint balance, uint denormalizedWeight) external virtual;\n    function applyAddToken() external virtual;\n    function removeToken(address token) external virtual;\n    function whitelistLiquidityProvider(address provider) external virtual;\n    function removeWhitelistedLiquidityProvider(address provider) external virtual;\n    function bPool() external view virtual returns (BPool);\n}\n\nabstract contract CRPFactory {\n    function newCrp(\n        address factoryAddress,\n        ConfigurableRightsPool.PoolParams calldata params,\n        RightsManager.Rights calldata rights\n    ) external virtual returns (ConfigurableRightsPool);\n}\n/********************************** WARNING **********************************/\n//                                                                           //\n// This contract is only meant to be used in conjunction with ds-proxy.      //\n// Calling this contract directly will lead to loss of funds.                //\n//                                                                           //\n/********************************** WARNING **********************************/\n\ncontract BActions {\n\n    // --- Pool Creation ---\n\n    function create(\n        BFactory factory,\n        address[] calldata tokens,\n        uint[] calldata balances,\n        uint[] calldata weights,\n        uint swapFee,\n        bool finalize\n    ) external returns (BPool pool) {\n        require(tokens.length == balances.length, \"ERR_LENGTH_MISMATCH\");\n        require(tokens.length == weights.length, \"ERR_LENGTH_MISMATCH\");\n\n        pool = factory.newBPool();\n        pool.setSwapFee(swapFee);\n\n        for (uint i = 0; i < tokens.length; i++) {\n            ERC20 token = ERC20(tokens[i]);\n            require(token.transferFrom(msg.sender, address(this), balances[i]), \"ERR_TRANSFER_FAILED\");\n            _safeApprove(token, address(pool), balances[i]);\n            pool.bind(tokens[i], balances[i], weights[i]);\n        }\n\n        if (finalize) {\n            pool.finalize();\n            require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n        } else {\n            pool.setPublicSwap(true);\n        }\n    }\n\n    function createSmartPool(\n        CRPFactory factory,\n        BFactory kFactory,\n        ConfigurableRightsPool.PoolParams calldata poolParams,\n        ConfigurableRightsPool.CrpParams calldata crpParams,\n        RightsManager.Rights calldata rights\n    ) external returns (ConfigurableRightsPool crp) {\n        require(\n            poolParams.constituentTokens.length == poolParams.tokenBalances.length,\n            \"ERR_LENGTH_MISMATCH\"\n        );\n        require(\n            poolParams.constituentTokens.length == poolParams.tokenWeights.length,\n            \"ERR_LENGTH_MISMATCH\"\n        );\n\n        crp = factory.newCrp(\n            address(kFactory),\n            poolParams,\n            rights\n        );\n\n        for (uint i = 0; i < poolParams.constituentTokens.length; i++) {\n            ERC20 token = ERC20(poolParams.constituentTokens[i]);\n            require(\n                token.transferFrom(msg.sender, address(this), poolParams.tokenBalances[i]),\n                \"ERR_TRANSFER_FAILED\"\n            );\n            _safeApprove(token, address(crp), poolParams.tokenBalances[i]);\n        }\n\n        crp.createPool(\n            crpParams.initialSupply,\n            crpParams.minimumWeightChangeBlockPeriod,\n            crpParams.addTokenTimeLockInBlocks\n        );\n        require(crp.transfer(msg.sender, crpParams.initialSupply), \"ERR_TRANSFER_FAILED\");\n        // DSProxy instance keeps pool ownership to enable management\n    }\n\n    // --- Joins ---\n\n    function joinPool(\n        BPool pool,\n        uint poolAmountOut,\n        uint[] calldata maxAmountsIn\n    ) external {\n        address[] memory tokens = pool.getFinalTokens();\n        _join(pool, tokens, poolAmountOut, maxAmountsIn);\n    }\n\n    function joinSmartPool(\n        ConfigurableRightsPool pool,\n        uint poolAmountOut,\n        uint[] calldata maxAmountsIn\n    ) external {\n        address[] memory tokens = pool.bPool().getCurrentTokens();\n        _join(pool, tokens, poolAmountOut, maxAmountsIn);\n    }\n\n    function joinswapExternAmountIn(\n        AbstractPool pool,\n        ERC20 token,\n        uint tokenAmountIn,\n        uint minPoolAmountOut\n    ) external {\n        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), \"ERR_TRANSFER_FAILED\");\n        _safeApprove(token, address(pool), tokenAmountIn);\n        uint poolAmountOut = pool.joinswapExternAmountIn(address(token), tokenAmountIn, minPoolAmountOut);\n        require(pool.transfer(msg.sender, poolAmountOut), \"ERR_TRANSFER_FAILED\");\n    }\n\n    // --- Pool management (common) ---\n\n    function setPublicSwap(AbstractPool pool, bool publicSwap) external {\n        pool.setPublicSwap(publicSwap);\n    }\n\n    function setSwapFee(AbstractPool pool, uint newFee) external {\n        pool.setSwapFee(newFee);\n    }\n\n    function setController(AbstractPool pool, address newController) external {\n        pool.setController(newController);\n    }\n\n    // --- Private pool management ---\n\n    function setTokens(\n        BPool pool,\n        address[] calldata tokens,\n        uint[] calldata balances,\n        uint[] calldata denorms\n    ) external {\n        require(tokens.length == balances.length, \"ERR_LENGTH_MISMATCH\");\n        require(tokens.length == denorms.length, \"ERR_LENGTH_MISMATCH\");\n\n        for (uint i = 0; i < tokens.length; i++) {\n            ERC20 token = ERC20(tokens[i]);\n            if (pool.isBound(tokens[i])) {\n                if (balances[i] > pool.getBalance(tokens[i])) {\n                    require(\n                        token.transferFrom(msg.sender, address(this), balances[i] - pool.getBalance(tokens[i])),\n                        \"ERR_TRANSFER_FAILED\"\n                    );\n                    _safeApprove(token, address(pool), balances[i] - pool.getBalance(tokens[i]));\n                }\n                if (balances[i] > 10**6) {\n                    pool.rebind(tokens[i], balances[i], denorms[i]);\n                } else {\n                    pool.unbind(tokens[i]);\n                }\n\n            } else {\n                require(token.transferFrom(msg.sender, address(this), balances[i]), \"ERR_TRANSFER_FAILED\");\n                _safeApprove(token, address(pool), balances[i]);\n                pool.bind(tokens[i], balances[i], denorms[i]);\n            }\n\n            if (token.balanceOf(address(this)) > 0) {\n                require(token.transfer(msg.sender, token.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n            }\n\n        }\n    }\n\n    function finalize(BPool pool) external {\n        pool.finalize();\n        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n    }\n\n    // --- Smart pool management ---\n\n    function increaseWeight(\n        ConfigurableRightsPool crp,\n        ERC20 token,\n        uint newWeight,\n        uint tokenAmountIn\n    ) external {\n        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), \"ERR_TRANSFER_FAILED\");\n        _safeApprove(token, address(crp), tokenAmountIn);\n        crp.updateWeight(address(token), newWeight);\n        require(crp.transfer(msg.sender, crp.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n    }\n\n    function decreaseWeight(\n        ConfigurableRightsPool crp,\n        ERC20 token,\n        uint newWeight,\n        uint poolAmountIn\n    ) external {\n        require(crp.transferFrom(msg.sender, address(this), poolAmountIn), \"ERR_TRANSFER_FAILED\");\n        crp.updateWeight(address(token), newWeight);\n        require(token.transfer(msg.sender, token.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n    }\n\n    function updateWeightsGradually(\n        ConfigurableRightsPool crp,\n        uint[] calldata newWeights,\n        uint startBlock,\n        uint endBlock\n    ) external {\n        crp.updateWeightsGradually(newWeights, startBlock, endBlock);\n    }\n\n    function setCap(\n        ConfigurableRightsPool crp,\n        uint newCap\n    ) external {\n        crp.setCap(newCap);\n    }\n\n    function commitAddToken(\n        ConfigurableRightsPool crp,\n        ERC20 token,\n        uint balance,\n        uint denormalizedWeight\n    ) external {\n        crp.commitAddToken(address(token), balance, denormalizedWeight);\n    }\n\n    function applyAddToken(\n        ConfigurableRightsPool crp,\n        ERC20 token,\n        uint tokenAmountIn\n    ) external {\n        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), \"ERR_TRANSFER_FAILED\");\n        _safeApprove(token, address(crp), tokenAmountIn);\n        crp.applyAddToken();\n        require(crp.transfer(msg.sender, crp.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n    }\n\n    function removeToken(\n        ConfigurableRightsPool crp,\n        ERC20 token,\n        uint poolAmountIn\n    ) external {\n        require(crp.transferFrom(msg.sender, address(this), poolAmountIn), \"ERR_TRANSFER_FAILED\");\n        crp.removeToken(address(token));\n        require(token.transfer(msg.sender, token.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n    }\n\n    function whitelistLiquidityProvider(\n        ConfigurableRightsPool crp,\n        address provider\n    ) external {\n        crp.whitelistLiquidityProvider(provider);\n    }\n\n    function removeWhitelistedLiquidityProvider(\n        ConfigurableRightsPool crp,\n        address provider\n    ) external {\n        crp.removeWhitelistedLiquidityProvider(provider);\n    }\n\n    // --- Internals ---\n\n    function _safeApprove(ERC20 token, address spender, uint amount) internal {\n        if (token.allowance(address(this), spender) > 0) {\n            token.approve(spender, 0);\n        }\n        token.approve(spender, amount);\n    }\n\n    function _join(\n        AbstractPool pool,\n        address[] memory tokens,\n        uint poolAmountOut,\n        uint[] memory maxAmountsIn\n    ) internal {\n        require(maxAmountsIn.length == tokens.length, \"ERR_LENGTH_MISMATCH\");\n\n        for (uint i = 0; i < tokens.length; i++) {\n            ERC20 token = ERC20(tokens[i]);\n            require(token.transferFrom(msg.sender, address(this), maxAmountsIn[i]), \"ERR_TRANSFER_FAILED\");\n            _safeApprove(token, address(pool), maxAmountsIn[i]);\n        }\n        pool.joinPool(poolAmountOut, maxAmountsIn);\n        for (uint i = 0; i < tokens.length; i++) {\n            ERC20 token = ERC20(tokens[i]);\n            if (token.balanceOf(address(this)) > 0) {\n                require(token.transfer(msg.sender, token.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n            }\n        }\n        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}